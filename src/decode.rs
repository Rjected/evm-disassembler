use std::collections::VecDeque;
use crate::types::{Opcode, Operation};

pub fn decode_operation(bytes: &mut VecDeque<u8>) -> Operation {
    match bytes.pop_front() {
        None => panic!("Unexpected end of input"),
        Some(value) => match value {
            0x00 => Operation::new(Opcode::STOP),
            0x01 => Operation::new(Opcode::ADD).with_stack_input(2, bytes),
            0x02 => Operation::new(Opcode::MUL).with_stack_input(2, bytes),
            0x03 => Operation::new(Opcode::SUB).with_stack_input(2, bytes),
            0x04 => Operation::new(Opcode::DIV).with_stack_input(2, bytes),
            0x05 => Operation::new(Opcode::SDIV).with_stack_input(2, bytes),
            0x06 => Operation::new(Opcode::MOD).with_stack_input(2, bytes),
            0x07 => Operation::new(Opcode::SMOD).with_stack_input(2, bytes),
            0x08 => Operation::new(Opcode::ADDMOD).with_stack_input(3, bytes),
            0x09 => Operation::new(Opcode::MULMOD).with_stack_input(3, bytes),
            0x0A => Operation::new(Opcode::EXP).with_stack_input(2, bytes),
            0x0B => Operation::new(Opcode::SIGNEXTEND).with_stack_input(2, bytes),
            0x10 => Operation::new(Opcode::LT).with_stack_input(2, bytes),
            0x11 => Operation::new(Opcode::GT).with_stack_input(2, bytes),
            0x12 => Operation::new(Opcode::SLT).with_stack_input(2, bytes),
            0x13 => Operation::new(Opcode::SGT).with_stack_input(2, bytes),
            0x14 => Operation::new(Opcode::EQ).with_stack_input(2, bytes),
            0x15 => Operation::new(Opcode::ISZERO).with_stack_input(1, bytes),
            0x16 => Operation::new(Opcode::AND).with_stack_input(2, bytes),
            0x17 => Operation::new(Opcode::OR).with_stack_input(2, bytes),
            0x18 => Operation::new(Opcode::XOR).with_stack_input(2, bytes),
            0x19 => Operation::new(Opcode::NOT).with_stack_input(1, bytes),
            0x1a => Operation::new(Opcode::BYTE).with_stack_input(2, bytes),
            0x1b => Operation::new(Opcode::SHL).with_stack_input(2, bytes),
            0x1c => Operation::new(Opcode::SHR).with_stack_input(2, bytes),
            0x1d => Operation::new(Opcode::SAR).with_stack_input(2, bytes),
            0x20 => Operation::new(Opcode::SHA3).with_stack_input(2, bytes),
            0x30 => Operation::new(Opcode::ADDRESS),
            0x31 => Operation::new(Opcode::BALANCE).with_stack_input(1, bytes),
            0x32 => Operation::new(Opcode::ORIGIN),
            0x33 => Operation::new(Opcode::CALLER),
            0x34 => Operation::new(Opcode::CALLVALUE),
            0x35 => Operation::new(Opcode::CALLDATALOAD),
            0x36 => Operation::new(Opcode::CALLDATASIZE),
            0x37 => Operation::new(Opcode::CALLDATACOPY).with_stack_input(3, bytes),
            0x38 => Operation::new(Opcode::CODESIZE),
            0x39 => Operation::new(Opcode::CODECOPY).with_stack_input(3, bytes),
            0x3a => Operation::new(Opcode::GASPRICE),
            0x3b => Operation::new(Opcode::EXTCODESIZE).with_stack_input(1, bytes),
            0x3c => Operation::new(Opcode::EXTCODECOPY).with_stack_input(4, bytes),
            0x3d => Operation::new(Opcode::RETURNDATASIZE),
            0x3e => Operation::new(Opcode::RETURNDATACOPY).with_stack_input(3, bytes),
            0x3f => Operation::new(Opcode::EXTCODEHASH).with_stack_input(1, bytes),
            0x40 => Operation::new(Opcode::BLOCKHASH).with_stack_input(1, bytes),
            0x41 => Operation::new(Opcode::COINBASE),
            0x42 => Operation::new(Opcode::TIMESTAMP),
            0x43 => Operation::new(Opcode::NUMBER),
            0x44 => Operation::new(Opcode::DIFFICULTY),
            0x45 => Operation::new(Opcode::GASLIMIT),
            0x46 => Operation::new(Opcode::CHAINID),
            0x47 => Operation::new(Opcode::SELFBALANCE),
            0x48 => Operation::new(Opcode::BASEFEE),
            0x50 => Operation::new(Opcode::POP).with_stack_input(1, bytes),
            _ => panic!("Invalid opcode: {}", value),
        },
    }
}

